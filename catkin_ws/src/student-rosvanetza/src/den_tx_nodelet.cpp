#include "den_tx_nodelet.hpp"
#include "vanetza/BtpData.h"
#include "vanetza/DenmTx.h"
#include "vanetza/SecurityIdChange.h"
#include <etsi_its_msgs/DENM.h>
#include <pluginlib/class_list_macros.h>
#include <ros/node_handle.h>
#include <vanetza/asn1/denm.hpp>
#include <vanetza/btp/ports.hpp>
#include <vanetza/common/its_aid.hpp>

PLUGINLIB_EXPORT_CLASS(vanetza::DenTxNodelet, nodelet::Nodelet)

namespace vanetza
{

void DenTxNodelet::onInit()
{
    ros::NodeHandle& nh = getNodeHandle();
    ros::NodeHandle& nhp = getPrivateNodeHandle();

    sub_id_change_ = nh.subscribe<vanetza::SecurityIdChange>("id_change", 3,
        [this](vanetza::SecurityIdChangeConstPtr change) {
            if (change->phase == vanetza::SecurityIdChange::PHASE_COMMIT)
            {
                station_id_ = change->id[4] << 24 | change->id[5] << 16 | change->id[6] << 8 | change->id[7];
                sequence_number_ = 0;
            }
        });

    btp_service_ = nh.serviceClient<vanetza::BtpData>("btp_request");
    den_service_ = nh.advertiseService("den_request", &DenTxNodelet::callback, this);
    purge_timer_ = nhp.createTimer(ros::Duration(10, 0), [this](const ros::TimerEvent&) { message_table_.purge(); });
    NODELET_INFO("Decentralized Environmental Notification transmitter nodelet initialised");
}

bool DenTxNodelet::callback(DenmTxRequest& request, DenmTxResponse& response)
{
    if (station_id_)
    {
        request.denm.its_header.protocol_version = 2; // see EN 302 637-3 v1.3.1
        request.denm.its_header.station_id = *station_id_;
    }
    else
    {
        return false;
    }

    if (request.request == DenmTxRequest::REQUEST_TRIGGER)
    {
        request.denm.management.action_id.station_id = *station_id_;
        request.denm.management.action_id.sequence_number = ++sequence_number_;
        message_table_.trigger(request.denm.management);
    }
    else if (request.request == DenmTxRequest::REQUEST_UPDATE)
    {
        // check message table if ActionID has been generated by us before
        if (!message_table_.update(request.denm.management))
        {
            response.confirm_den = DenmTxResponse::CONFIRM_DEN_INVALID_ACTION_ID;
            return true;
        }
    }
    else if (request.request == DenmTxRequest::REQUEST_TERMINATION)
    {
        bool own_denm = message_table_.exists(request.denm.management.action_id);
        request.denm.management.termination = own_denm ?
            etsi_its_msgs::ManagementContainer::TERMINATION_CANCELLATION :
            etsi_its_msgs::ManagementContainer::TERMINATION_NEGATION;
        message_table_.terminate(request.denm.management);
    }
    else
    {
        response.confirm_den = DenmTxResponse::CONFIRM_DEN_INVALID_REQUEST;
        return true;
    }
    vanetza::asn1::Denm message = convertMessage(request.denm);

    try
    {
        BtpDataResponse btp_response = transmitMessage(request, message.encode());
        response.confirm_den = btp_response.confirm == BtpDataResponse::CONFIRM_ACCEPTED ?
            DenmTxResponse::CONFIRM_DEN_ACCEPTED : DenmTxResponse::CONFIRM_DEN_BTP_FAILURE;
        response.confirm_btp = btp_response.confirm;
    }
    catch (const std::exception& e)
    {
        NODELET_ERROR("Encoding DENM failed: %s", e.what());
        response.confirm_den = DenmTxResponse::CONFIRM_DEN_ENCODING_FAILURE;
    }

    response.action_id = request.denm.management.action_id;
    return true;
}

BtpDataResponse DenTxNodelet::transmitMessage(const DenmTxRequest& request, std::vector<std::uint8_t>&& data)
{
    using DataRequest = vanetza::BtpDataRequest;
    vanetza::BtpData btp_data;
    DataRequest& btp_request = btp_data.request;
    btp_request.btp_type = DataRequest::BTP_TYPE_B;
    btp_request.destination_port = vanetza::btp::ports::DENM.host();
    btp_request.destination_port_info = 0;
    btp_request.transport_type = DataRequest::TRANSPORT_TYPE_GBC;
    btp_request.destination.type = vanetza::GeoNetDestination::TYPE_AREA;
    btp_request.destination.area = request.destination_area;
    btp_request.its_aid = vanetza::aid::DEN;
    btp_request.traffic_class = request.traffic_class;
    // TODO handle repetitions on applicaton layer (DenTxNodelet) not by networking layer
    btp_request.repetition_interval = request.repetition_interval;
    btp_request.repetition_duration = request.repetition_duration;
    btp_request.data = std::move(data);

    if (!btp_service_.call(btp_data))
    {
        NODELET_ERROR("Passing DENM to BTP-DATA.request service failed");
        btp_data.response.confirm = BtpDataResponse::CONFIRM_REJECTED_UNSPECIFIED;
    }
    return btp_data.response;
}

vanetza::asn1::Denm DenTxNodelet::convertMessage(const etsi_its_msgs::DENM& msg) const
{
    vanetza::asn1::Denm asn1;

    // ITS header
    ItsPduHeader_t& header = asn1->header;
    header.protocolVersion = msg.its_header.protocol_version;
    header.messageID = ItsPduHeader__messageID_denm;
    header.stationID = msg.its_header.station_id;

    // management container
    ManagementContainer_t& management = asn1->denm.management;
    management.actionID.originatingStationID = msg.management.action_id.station_id;
    management.actionID.sequenceNumber = msg.management.action_id.sequence_number;
    asn_ulong2INTEGER(&management.detectionTime, msg.management.detection_time);
    asn_ulong2INTEGER(&management.referenceTime, msg.management.reference_time);
    if (msg.management.termination != etsi_its_msgs::ManagementContainer::TERMINATION_UNAVAILABLE)
    {
        management.termination = vanetza::asn1::allocate<Termination_t>();
        *management.termination = msg.management.termination;
    }
    management.eventPosition.longitude = msg.management.event_position.longitude;
    management.eventPosition.latitude = msg.management.event_position.latitude;
    management.eventPosition.altitude.altitudeValue = msg.management.event_position.altitude.value;
    management.eventPosition.altitude.altitudeConfidence = msg.management.event_position.altitude.confidence;
    management.eventPosition.positionConfidenceEllipse.semiMinorConfidence =
        msg.management.event_position.position_confidence.semi_minor_confidence;
    management.eventPosition.positionConfidenceEllipse.semiMajorConfidence =
        msg.management.event_position.position_confidence.semi_major_confidence;
    management.eventPosition.positionConfidenceEllipse.semiMajorOrientation =
        msg.management.event_position.position_confidence.semi_major_orientation;
    if (msg.management.relevance_distance.value != etsi_its_msgs::RelevanceDistance::UNAVAILABLE)
    {
        management.relevanceDistance = vanetza::asn1::allocate<RelevanceDistance_t>();
        *management.relevanceDistance = msg.management.relevance_distance.value;
    }
    if (msg.management.relevance_traffic_direction.value != etsi_its_msgs::RelevanceTrafficDirection::UNAVAILABLE)
    {
        management.relevanceTrafficDirection = vanetza::asn1::allocate<RelevanceTrafficDirection_t>();
        *management.relevanceTrafficDirection = msg.management.relevance_traffic_direction.value;
    }
    if (msg.management.validity_duration != etsi_its_msgs::ManagementContainer::VALIDITY_DURATION_DEFAULT)
    {
        management.validityDuration = vanetza::asn1::allocate<ValidityDuration_t>();
        *management.validityDuration = msg.management.validity_duration;
    }
    if (msg.management.transmission_interval != etsi_its_msgs::ManagementContainer::TRANSMISSION_INTERVAL_UNAVAILABLE)
    {
        management.transmissionInterval = vanetza::asn1::allocate<TransmissionInterval_t>();
        *management.transmissionInterval = msg.management.transmission_interval;
    }
    management.stationType = msg.management.station_type.value;

    // situation container
    if (msg.has_situation)
    {
        asn1->denm.situation = vanetza::asn1::allocate<SituationContainer_t>();
        SituationContainer_t& situation = *asn1->denm.situation;

        situation.informationQuality = msg.situation.information_quality.value;
        situation.eventType.causeCode = msg.situation.event_type.cause_code;
        situation.eventType.subCauseCode = msg.situation.event_type.sub_cause_code;
        if (msg.situation.has_linked_cause)
        {
            situation.linkedCause = vanetza::asn1::allocate<CauseCode_t>();
            situation.linkedCause->causeCode = msg.situation.linked_cause.cause_code;
            situation.linkedCause->subCauseCode = msg.situation.linked_cause.sub_cause_code;
        }
        if (!msg.situation.event_history.empty())
        {
            situation.eventHistory = vanetza::asn1::allocate<EventHistory_t>();
            for (const etsi_its_msgs::EventPoint& msg_point : msg.situation.event_history)
            {
                EventPoint_t* point = vanetza::asn1::allocate<EventPoint_t>();
                point->eventPosition.deltaLatitude = msg_point.event_position.delta_latitude;
                point->eventPosition.deltaLongitude = msg_point.event_position.delta_longitude;
                point->eventPosition.deltaAltitude = msg_point.event_position.delta_altitude;
                if (msg_point.event_delta_time.value != etsi_its_msgs::PathDeltaTime::UNAVAILABLE)
                {
                    point->eventDeltaTime = vanetza::asn1::allocate<PathDeltaTime_t>();
                    *point->eventDeltaTime = msg_point.event_delta_time.value;
                }
                point->informationQuality = msg_point.information_quality.value;
                ASN_SEQUENCE_ADD(situation.eventHistory, point);
            }
        }
    }

    // location container
    if (msg.has_location)
    {
        asn1->denm.location = vanetza::asn1::allocate<LocationContainer_t>();
        LocationContainer_t& location = *asn1->denm.location;

        if (msg.location.event_speed.value != etsi_its_msgs::Speed::VALUE_UNAVAILABLE)
        {
            location.eventSpeed = vanetza::asn1::allocate<Speed_t>();
            location.eventSpeed->speedValue = msg.location.event_speed.value;
            location.eventSpeed->speedConfidence = msg.location.event_speed.confidence;
        }
        if (msg.location.event_position_heading.value != etsi_its_msgs::Heading::VALUE_UNAVAILABLE)
        {
            location.eventPositionHeading = vanetza::asn1::allocate<Heading_t>();
            location.eventPositionHeading->headingValue = msg.location.event_position_heading.value;
            location.eventPositionHeading->headingConfidence = msg.location.event_position_heading.confidence;
        }
        if (!msg.location.traces.empty())
        {
            for (const etsi_its_msgs::PathHistory& msg_history : msg.location.traces)
            {
                PathHistory_t* history = vanetza::asn1::allocate<PathHistory_t>();
                for (const etsi_its_msgs::PathPoint& msg_point : msg_history.points)
                {
                    PathPoint_t* point = vanetza::asn1::allocate<PathPoint_t>();
                    point->pathPosition.deltaLatitude = msg_point.path_position.delta_latitude;
                    point->pathPosition.deltaLongitude = msg_point.path_position.delta_longitude;
                    point->pathPosition.deltaAltitude = msg_point.path_position.delta_altitude;
                    if (msg_point.path_delta_time.value != etsi_its_msgs::PathDeltaTime::UNAVAILABLE)
                    {
                        point->pathDeltaTime = vanetza::asn1::allocate<PathDeltaTime_t>();
                        *point->pathDeltaTime = msg_point.path_delta_time.value;
                    }
                    ASN_SEQUENCE_ADD(history, point);
                }
                ASN_SEQUENCE_ADD(&location.traces, history);
            }
        }
        else
        {
            ASN_SEQUENCE_ADD(&location.traces, vanetza::asn1::allocate<PathHistory_t>());
        }
        
        if (msg.location.road_type != etsi_its_msgs::LocationContainer::ROAD_TYPE_UNAVAILABLE)
        {
            location.roadType = vanetza::asn1::allocate<RoadType_t>();
            *location.roadType = msg.location.road_type;
        }
    }

    return asn1;
}

} // namespace vanetza
